#include <stdio.h>
#include <stdlib.h>
#include <math.h>
struct Gauss{// Give crossings, sign, over/under. Seems like you can do this in a matrix...
int crossings; //number of crossings.
int components; //number of components in link
int *sizecomp; //gives sizes of each component
int ***matrix; 
int splices;
/* components # of matrices....
(Each matrix has three rows: Top row gives crossing numbers )
second row gives over/under crossing (Over = one, Under = zero)
third row gives +/-.*/
int startcross; /*starting crossing*/
int ovorun;//overcrossing or undercrossing for startcross??
int sign; //sign of startcross (+/- 1)
};
int isitsmaller(struct Gauss k1){
    int counter, counter1, counter2;
    int cases = 1; //zero if crossing is a real crossing in a knot, one if it is some intersection between two knots
    int mat1,col1,mat2,col2;
    for (counter = 0; counter<k1.components; counter++){ //iterate through components
        counter2 = 0; //initialize counter2 to zero every time I get here.
        for (counter1 = 0; counter1<k1.sizecomp[counter]; counter1++){ //loop through the columns of each matrix
            if (k1.matrix[counter][counter1][0]==k1.startcross){//check if it is the right crossing
                counter2++;//if it is, increment counter 2.
            }
            if(counter2 == 2){//if counter2 has been incremented twice, it means that the crossing is not an interaction between two knots
                cases = 0;//set cases to zero.
                break;
            }
        }
        if(counter2 == 2){//if counter2 has been incremented twice-> not an interaction between two knots
            cases = 0;//thus, we can set cases to zero.
            break;
        }
    }
    return cases;
}
struct Gauss splice(struct Gauss k1){
    struct Gauss modknot;
    modknot.crossings = k1.crossings-1; //splicing reduces crossings by 1
    modknot.splices = k1.splices + 1;
    int counter, counter1, counter2,counter3;
    int len1,len2;
    counter3 = 0;
    int cases = isitsmaller(k1); //0 if crossing is a real crossing in a knot, 1 if it is some intersection between two knots....
    int mat1,col1,mat2,col2;
    for (counter = 0; counter<k1.components; counter++){ //iterate through components
        if(counter3 == 2){// If we've found both instances, we're done!
            break;
        }
        for (counter1 = 0; counter1<k1.sizecomp[counter]; counter1++){ //loop through the columns of each matrix
            if(counter3 == 2){// If we've found both instances, we're done!
                break;
            }
            if (k1.matrix[counter][counter1][0]==k1.startcross){//check if it is the right crossing
                if (counter3 == 0){// we do not want to search for this again, so we do our search here.
                    mat1 = counter;// set mat1 to the first matrix where I find it.
                    col1 = counter1;// set col1 to the first column where I find it.
                }
                if (counter3 == 1){
                    mat2 = counter; //set mat2 to the second matrix where I find it
                    col2 = counter1; //set col2 to the second column where I find it.
                }
                counter3++; //increment counter3 so that it is one the second time that I find k.
            }
        }
    }
    len1 = k1.sizecomp[mat1];
    len2 = k1.sizecomp[mat2];
    if (cases == 0){
        modknot.components=k1.components+1;//if both are in the same knot, we add one to components, but if they are in different knots, we subtract 1.
    }
    if (cases == 1){
        modknot.components = k1.components-1;//if both are in the same knot, we add one to components, but if they are in different knots, we subtract 1.
    }
    modknot.sizecomp = (int*) malloc(modknot.components*sizeof(int));//allocate memory to modknot.sizecomp
    if (cases == 1){//if it is in 2 knots, merge the two knots!
        counter = 0; //initialize counters to zero
        counter1 = 0; //initialize counters to zero
        while(counter < modknot.components){//iterate through components
            if (counter == mat2){
                counter1++; //skip it!
            }
            modknot.sizecomp[counter]=k1.sizecomp[counter1];// copy
            if (counter == mat1){//special case. Want to add their sizes
                modknot.sizecomp[counter] += k1.sizecomp[mat2];// should be the size of the sum.
            }
            counter++;//increment both counters.
            counter1++;
        }
    }
    if (cases == 0){//Increments number of things by one. Must add new knot to link. I will add it to the end.
        counter = 0; //initialize counter2 to zero
        while(counter < modknot.components){//iterate through components
            if (counter == mat1){//special case.
                modknot.sizecomp[counter] = col2-col1;
            }
            if (counter != mat1 && counter !=modknot.components-1){
                modknot.sizecomp[counter] = k1.sizecomp[counter];
            }
            if (counter ==  modknot.components-1){
                modknot.sizecomp[counter] = k1.sizecomp[mat1]+col1-col2;//length of mat1 minus stuff
            }
            counter++;//increment counter
        }
    }
    modknot.matrix = (int***) malloc(modknot.components*sizeof(int**));//allocate memory to modknot.matrix
    for (counter1 = 0; counter1<modknot.components; counter1++){
        modknot.matrix[counter1] = (int**) malloc(modknot.sizecomp[counter1]*sizeof(int*));//allocate memory to each matrix within modknot.matrix
        for(counter2 = 0; counter2<modknot.sizecomp[counter1]; counter2++){
            modknot.matrix[counter1][counter2] = (int*) malloc(3*sizeof(int));//allocate memory to each column within the matrix
        }
    }
    if (cases == 1){//hijack the same logic used in sizecomp to make the new matrix.
        counter = 0; //initialize counters to zero
        counter1 = 0; //initialize counters to zero
        while(counter < modknot.components){//iterate through components
            if (counter == mat2){//skip over second matrix. Will keep everything in the same place. Only deletes the matrix.
                counter1++; //skip it!
            }
            if (counter == mat1){//special case. Want to add their sizes AxB, CxD->ADBC.
                for(counter2 = 0; counter2<col1; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[mat1][counter2][counter3] = k1.matrix[mat1][counter2][counter3];
                    }
                }
                modknot.matrix[mat1][col1][0] = -1;//give nonsensical value for crossing number so I can skip over it later
                modknot.matrix[mat1][col1][1] = k1.matrix[mat1][col1][1];
                modknot.matrix[mat1][col1][2] = k1.matrix[mat1][col1][2];
                for(counter2 = 0; counter2 < len2-col2-1; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[mat1][counter2+col1+1][counter3] = k1.matrix[mat2][counter2+col2+1][counter3];
                    }
                }
                for(counter2 = 0; counter2<len1-col1-1; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[mat1][counter2+col1+len2-col2][counter3] = k1.matrix[mat1][counter2+col1+1][counter3];
                    }
                }
                modknot.matrix[mat1][len1+len2-col2-1][0] = -1;//give nonsensical value for crossing number so I can skip over it later
                modknot.matrix[mat1][len1+len2-col2-1][1] = k1.matrix[mat2][col2][1];
                modknot.matrix[mat1][len1+len2-col2-1][2] = k1.matrix[mat2][col2][2];
                for(counter2 = 0; counter2<col2; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[mat1][counter2+len1+len2-col2][counter3] = k1.matrix[mat2][counter2][counter3];
                    }
                }
            }
            if (counter != mat1 && counter!= mat2){//last case
                for (counter2 = 0; counter2<modknot.sizecomp[counter1]; counter2++){//loop
                    for (counter3 = 0; counter3<3;counter3++){//loop
                        modknot.matrix[counter][counter2][counter3]=k1.matrix[counter1][counter2][counter3]; //Set these two equal.
                    }
                }
            }
            counter++;//increment both counters.
            counter1++;
        }
    }
    if (cases == 0){//hijacks same logic to make the new matrix
        counter = 0; //initialize counters to zero
        while(counter < modknot.components){//iterate through components
            if (counter == mat1){//special case. Want to add their sizes AxBxC->xB,AxC
                for(counter2 = 0; counter2<col2-col1; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[mat1][counter2][counter3] = k1.matrix[mat1][counter2+col1][counter3];
                    }
                }
            }
            if (counter == modknot.components-1){
                for(counter2 = 0; counter2<col1; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[counter][counter2][counter3] = k1.matrix[mat1][counter2][counter3];
                    }
                }
                for(counter2 = 0; counter2<k1.sizecomp[mat1]-col2; counter2++){
                    for(counter3 = 0; counter3<3;counter3++){
                        modknot.matrix[counter][counter2+col1][counter3] = k1.matrix[mat1][counter2+col2][counter3];
                    }
                }
            }
            if (counter != mat1 && counter != modknot.components-1){//last case
                for (counter2 = 0; counter2<modknot.sizecomp[counter]; counter2++){//loop
                    for (counter3 = 0; counter3<3;counter3++){//loop
                        modknot.matrix[counter][counter2][counter3]=k1.matrix[counter][counter2][counter3]; //Set these two equal.
                    }
                }
            }
            counter++;//increment both counters.
        }
    }
    for(counter = 0; counter < modknot.components; counter++){// loop through components
        for(counter1 = 0; counter1 < modknot.sizecomp[counter]; counter1++){//loop through crossings
            if (modknot.matrix[counter][counter1][0] == k1.startcross){//if we have found our crossing
                modknot.matrix[counter][counter1][0] = -1;//kill it. Set it to -1. We will never care about it again!
                if(modknot.matrix[counter][counter1][1] == k1.ovorun){ //if it is the right instance
                    mat1 = counter; //set mat1 and col1 accordingly
                    col1 = counter1;
                }
            }
        }
    }
    int modcount,modcount1,modcount2;
    int found = 0;
    for(counter = 1; counter<modknot.components+1;counter++){
        if (found == 1){
            break;
        }
        modcount = (counter + mat1) % modknot.components;
        for(counter1 = 1; counter1<modknot.sizecomp[modcount]+1;counter1++){
            if (found == 1){
                break;
            }
            modcount1 = (counter1+col1) % modknot.sizecomp[modcount];
            for(counter2 = 0; counter2<3;counter2++){
                if (found == 1){
                    break;
                }
                if (modknot.matrix[modcount][modcount1][0] != -1){
                    modknot.startcross = modknot.matrix[modcount][modcount1][0];
                    modknot.ovorun = modknot.matrix[modcount][modcount1][1];
                    modknot.sign = modknot.matrix[modcount][modcount1][2];
                    found = 1;
                }
            }
        }
    }
    return modknot;//return modified knot
}
struct Gauss virtue(struct Gauss k1){//we make crossing k1.startcross virtual by setting its number to -1
    int counter, counter1, counter2, counter3 = 0; //4 counters
    int mat1, col1;
    int found = 0;
    struct Gauss modknot;
    modknot.splices = k1.splices;
    modknot.crossings = k1.crossings-1; //We treat this as if we have gotten rid of the crossing. Bye bye!
    modknot.components = k1.components;//components should be the same
    modknot.sizecomp = (int*) malloc(modknot.components*sizeof(int));//allocate memory to modknot.sizecomp
    for (int i = 0; i < modknot.components; i++) {
        modknot.sizecomp[i] = k1.sizecomp[i];
    }
    modknot.matrix = (int***) malloc(modknot.components * sizeof(int**));
    for (int i = 0; i < modknot.components; i++) {
        modknot.matrix[i] = (int**) malloc(modknot.sizecomp[i] * sizeof(int*));
        for (int j = 0; j < modknot.sizecomp[i]; j++) {
            modknot.matrix[i][j] = (int*) malloc(3 * sizeof(int));
        }
    }
    for (int i = 0; i < modknot.components; i++) {
        for (int j = 0; j < modknot.sizecomp[i]; j++) {
            for (int k = 0; k < 3; k++) {
                modknot.matrix[i][j][k] = k1.matrix[i][j][k];
            }

            if (k1.matrix[i][j][0] == k1.startcross) {
                modknot.matrix[i][j][0] = -1; // virtualize
                if (k1.matrix[i][j][1] == k1.ovorun) {
                    mat1 = i;
                    col1 = j;
                }
            }
        }
    }
    int modcount,modcount1,modcount2;
    for(counter = 1; counter<modknot.components+1;counter++){
        if (found == 1){
            break;
        }
        modcount = (counter + mat1) % modknot.components;
        for(counter1 = 1; counter1<modknot.sizecomp[modcount]+1;counter1++){
            if (found == 1){
                break;
            }
            modcount1 = (counter1+col1) % modknot.sizecomp[modcount];
            for(counter2 = 0; counter2<3;counter2++){
                if (found == 1){
                    break;
                }
                if (modknot.matrix[modcount][modcount1][0] != -1){
                    modknot.startcross = modknot.matrix[modcount][modcount1][0];
                    modknot.ovorun = modknot.matrix[modcount][modcount1][1];
                    modknot.sign = modknot.matrix[modcount][modcount1][2];
                    found = 1;
                }
            }
        }
    }
    return modknot;
}
/*Now, we must carry out the skein template algorithm for t and use Lagrange interpolation on the result. THE ABOVE DEFINITELY WORKS. I AM SURE OF THIS.
Jones_Partial has some error in it. I need to rectify it...*/
void free_gauss(struct Gauss k) {
    for (int i = 0; i < k.components; i++) {
        for (int j = 0; j < k.sizecomp[i]; j++) {
            free(k.matrix[i][j]);
        }
        free(k.matrix[i]);
    }
    free(k.matrix);
    free(k.sizecomp);
}
int writhe(struct Gauss k1){ //This one works.
    int counter, counter1, result;
    result = 0;
    for(counter = 0; counter < k1.components; counter++){
        for(counter1 = 0; counter1 < k1.sizecomp[counter]; counter1++){
            result += k1.matrix[counter][counter1][2];
        }
    }
    return result/2; //CROSSINGS HAPPEN TWICE!! I AM AN IDIOT!
}
float Jones_Partial(struct Gauss k1, float n) {
    // Jones specialization
    float alpha = 1.0/n/n;       
    float z     = n - 1.0 / n;  
    float delta = -n - 1.0/n;
    // Base case: no crossings
    if (k1.crossings == 0){
        return powf(delta,k1.components-1);
    }
    // Overcrossing: one branch (decorate)
    if (k1.ovorun == 1) {
        struct Gauss k2 = virtue(k1);
        float J2 = Jones_Partial(k2, n);
        free_gauss(k2);
        if (k1.sign == 1){
            return alpha*J2;
        }
        if (k1.sign == -1){
            return J2/alpha;
        }
    }

    // Undercrossing: two branches (switch + splice)
    struct Gauss k2 = virtue(k1);
    float J2 = Jones_Partial(k2, n);
    free_gauss(k2);

    struct Gauss k3 = splice(k1);
    float J3 = Jones_Partial(k3, n);
    free_gauss(k3);

    if (k1.sign == 1) {
        if (isitsmaller(k1) == 0){
            return J2/alpha + z*J3;
        }
        if (isitsmaller(k1) == 1){
            return J2/alpha + z*J3;
        }
    } 
    else {
        if (isitsmaller(k1) == 0){
            return J2*alpha - z*J3;
        }
    }
    return J2*alpha - z*J3;
}
float Jones_Eval(struct Gauss k1, float n){
    float alpha = 1.0 /n/n;
    return powf(alpha, -writhe(k1))*Jones_Partial(k1,n);
}
struct poly{// polynomial structure
    float *poly; //polynomial coefficients in pointer
    int deg; //degree
};
struct poly polyplus(struct poly p1, struct poly p2){
    struct poly p3;
    float p1coeff, p2coeff;
    int counter = 0;
    p3.deg = (p1.deg > p2.deg)? p1.deg : p2.deg;
    p3.poly = (float*) malloc((p3.deg + 1) * sizeof(float)); // Allocates bits of memory to store values in the pointers
    while (counter <= p3.deg){
        if (counter <= p1.deg) {
            p1coeff = *(p1.poly + counter);
        } else {
            p1coeff = 0;
        }

        if (counter <= p2.deg) {
            p2coeff = *(p2.poly + counter);
        } else {
            p2coeff = 0;
        }

        *(p3.poly + counter) = p1coeff + p2coeff;
        counter++;
    }
    return p3;
}
struct poly polyminus(struct poly p1, struct poly p2){
    struct poly p3;
    float p1coeff, p2coeff;
    int counter = 0;
    p3.deg = (p1.deg > p2.deg)? p1.deg : p2.deg;
    p3.poly = (float*) malloc((p3.deg + 1) * sizeof(float)); // Allocates bits of memory to store values in the pointers
    while (counter <= p3.deg){
        if (counter <= p1.deg) {
            p1coeff = *(p1.poly + counter);
        } else {
            p1coeff = 0;
        }

        if (counter <= p2.deg) {
            p2coeff = *(p2.poly + counter);
        } else {
            p2coeff = 0;
        }

        *(p3.poly + counter) = p1coeff - p2coeff;
        counter++;
    }
    return p3;
}
struct poly polytimes(struct poly p1, struct poly p2) {
    struct poly p3;
    p3.deg = p1.deg + p2.deg;
    p3.poly = (float*) malloc((p3.deg + 1) * sizeof(float)); // Allocate memory for the result
    for (int i = 0; i <= p3.deg; i++) {
        p3.poly[i] = 0;  // Initialize the coefficients to zero
    }
    // Multiply the two polynomials
    for (int i = 0; i <= p1.deg; i++) {
        for (int j = 0; j <= p2.deg; j++) {
            p3.poly[i + j] += p1.poly[i] * p2.poly[j];
        }
    }
    return p3;
}
struct poly choose(int n) {
    struct poly output;
    if (n == 0) {
        output.deg = 0;
        output.poly = (float*) malloc(1 * sizeof(float));
        output.poly[0] = 1; // one if zero is inputted
    }
    else if (n == 1) {
        output.deg = 1;
        output.poly = (float*) malloc(2 * sizeof(float));
        output.poly[0] = 0;
        output.poly[1] = 1; //x if one is inputted
    }
    else {
        struct poly pn;
        pn.deg = 1;
        pn.poly = (float*) malloc(2 * sizeof(float));
        pn.poly[0] = -(n-1.0)/n; // recursive definition. Multiplies by (x-n+1)/n each time.
        pn.poly[1] = 1.0/n;
        struct poly lower = choose(n - 1);
        output = polytimes(pn, lower);
        free(pn.poly); // free memory
    }
    return output;
}
struct poly lagrange(float values[], int n) {
    float diff[n][n];
    int counter1, counter2, counter3, counter4, counter5;
    // first column of the difference table
    for (counter1 = 0; counter1 < n; counter1++) {
        diff[0][counter1] = values[counter1];
    }
    // rest of the difference table
    for (counter2 = 1; counter2 < n; counter2++) {
        for (counter3 = 0; counter3 < n - counter2; counter3++) {
            diff[counter2][counter3] = diff[counter2 - 1][counter3 + 1] - diff[counter2 - 1][counter3];
        }
    }
    struct poly coeffs[n];
    for (counter4 = 0; counter4 < n; counter4++) {
        coeffs[counter4].deg = 0; // Degree of Lagrange basis polynomial
        coeffs[counter4].poly = (float*) malloc(1 * sizeof(float));
        coeffs[counter4].poly[0] = diff[counter4][0];
    }
    struct poly finalpoly;
    finalpoly.deg = 0;
    finalpoly.poly = (float*) malloc(1 * sizeof(float));
    finalpoly.poly[0] = 0; // Construct the final polynomial by summing the product of the coefficients and Lagrange basis polynomials
    for (counter5 = 0; counter5 < n; counter5++) {
        coeffs[counter5] = polytimes(coeffs[counter5], choose(counter5));
        finalpoly = polyplus(finalpoly, coeffs[counter5]);
    }
    for (counter4 = 0; counter4 < n; counter4++) {
        free(coeffs[counter4].poly);
    }
    return finalpoly;
}
struct poly JONES(struct Gauss k1){//Pretty sure that this works....
    int n = 2*k1.crossings; //CHANGE TO ACTUAL NUMBER BASED OFF OF NUMBER OF CROSSINGS!!! SEE THIS, EVAN. DO NOT BE BLIND. (third person commentary...)
    float values[n+1];
    values[0] = 0;// SET THIS TO 0.
    int counter;
    float conter = 1.0;//version of counter which is the same, but just a float. It "cons" the program into thinking that counter is a float.
    int power = 2*k1.crossings+1;// CHANGE TO ACTUAL NUMBER BASED ON NUMBER OF CROSSINGS!!! SEE THIS, EVAN. DO NOT BE BLIND.
    for(counter = 1; counter < n+1; counter++){
        values[counter] = pow(conter,power)*Jones_Eval(k1,conter);// JONES CAN HAVE NEGATIVE TERMS.
        conter++;
    }
    struct poly jones; //gimme the jones poly....
    jones.deg = n;
    jones = lagrange(values, n+1);
    for (int i = 0; i < n+1; i++){
        if(jones.poly[i] != 0){
            printf("%f t^(%d) + ", jones.poly[i], i-power);
        }
    }
    return jones;
}
int main() {
    struct Gauss trefoil;
    trefoil.crossings = 3;
    trefoil.components = 1;
    trefoil.splices = 0;
    trefoil.sizecomp = (int*) malloc(sizeof(int));
    trefoil.sizecomp[0] = 6;
    trefoil.matrix = (int***) malloc(sizeof(int**));
    trefoil.matrix[0] = (int**) malloc(6 * sizeof(int*));
    for (int i = 0; i < 6; i++) {
        trefoil.matrix[0][i] = (int*) malloc(3 * sizeof(int));
    }
    int data[6][3] = {
        {1, 1, 1},  // Crossing one, Over, Positive
        {2, 0, 1},  // Crossing two, Under, Positive
        {3, 1, 1},  // Crossing three, Over, Positive
        {1, 0, 1},  // Crossing one again, Under, Positive
        {2, 1, 1},  // Crossing two again, Over, Positive
        {3, 0, 1}   // Crossing three again, Under, Positive
    };
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 3; j++) {
            trefoil.matrix[0][i][j] = data[i][j];
        }
    }
    trefoil.startcross = 1;
    trefoil.ovorun = 1;
    trefoil.sign = 1;
    JONES(trefoil);
    for (int i = 0; i < 6; i++) {
        free(trefoil.matrix[0][i]);
    }
    free(trefoil.matrix[0]);
    free(trefoil.matrix);
    free(trefoil.sizecomp);
    return 0;
}
